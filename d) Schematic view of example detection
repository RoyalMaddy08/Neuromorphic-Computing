import numpy as np
import matplotlib.pyplot as plt

# Function to calculate squared Euclidean distance components
def squared_euclidean_distance(x, xi):
    return np.sum((x - xi) ** 2)

# Function to model the operational amplifier output
def op_amp_output(x, xi, Gu, Vu, Rf):
    D_squared = squared_euclidean_distance(x, xi)
    V_out = -Rf * Vu * Gu * D_squared
    return V_out, D_squared

# Function to generate random input and stored vectors
def generate_vectors(num_vectors, dim):
    np.random.seed(42)  # For reproducibility
    x_random = np.random.rand(num_vectors, dim)
    xi_random = np.random.rand(num_vectors, dim)
    return x_random, xi_random

# Function to implement the dynamic threshold mechanism
def dynamic_threshold(V_out, VETH_values):
    return V_out < VETH_values

# Parameters
num_vectors = 100
dim = 10
Gu = 1e-6  # Unit conductance (1 µS)
Vu = 1  # Unit voltage (1 V)
Rf = 1e4  # Feedback resistor (10 kΩ)
VETH_values = np.arange(0, 0.05, 0.005)  # Dynamic threshold voltage range (0 to 50 mV)

# Generate random input and stored vectors
x_random, xi_random = generate_vectors(num_vectors, dim)

# Calculate distances and operational amplifier outputs
V_out_values = []
D_squared_values = []
for i in range(num_vectors):
    V_out, D_squared = op_amp_output(x_random[i], xi_random[i], Gu, Vu, Rf)
    V_out_values.append(V_out)
    D_squared_values.append(D_squared)

V_out_values = np.array(V_out_values)
D_squared_values = np.array(D_squared_values)

# Comparator outputs for different VETH values
comparator_outputs = [dynamic_threshold(V_out_values, VETH) for VETH in VETH_values]

# Plot results
plt.figure(figsize=(14, 6))

# Op-Amp Output vs. Traditional Euclidean Distance
plt.subplot(1, 2, 1)
plt.plot(D_squared_values, V_out_values, 'ro')
plt.xlabel('Squared Euclidean Distance')
plt.ylabel('Op-Amp Output Voltage (V)')
plt.title('Op-Amp Output vs. Squared Euclidean Distance')
plt.grid(True)

# Comparator Output vs. VETH
plt.subplot(1, 2, 2)
for i, VETH in enumerate(VETH_values):
    plt.plot(VETH, comparator_outputs[i].sum() / num_vectors, 'bo')
plt.xlabel('Dynamic Threshold Voltage (VETH) (V)')
plt.ylabel('Comparator Output (Fraction of vectors below threshold)')
plt.title('Comparator Output vs. VETH')
plt.grid(True)

plt.tight_layout()
plt.show()

# Error Analysis
errors = D_squared_values - V_out_values
plt.figure(figsize=(10, 6))
plt.hist(errors, bins=20, edgecolor='k', alpha=0.7)
plt.xlabel('Error')
plt.ylabel('Frequency')
plt.title('Error Distribution between Squared Euclidean Distance and Op-Amp Output')
plt.show()

# Statistical Measures
mean_error = np.mean(errors)
std_error = np.std(errors)
print(f"Mean Error: {mean_error}")
print(f"Standard Deviation of Error: {std_error}")

# Analysis
# a. Correlation between the operational amplifier output and the actual Euclidean distance
correlation = np.corrcoef(D_squared_values, V_out_values)[0, 1]
print(f"Correlation between Op-Amp output and squared Euclidean distance: {correlation}")

# b. Evaluate the effectiveness of the dynamic threshold in detecting similar vectors
effectiveness = comparator_outputs[-1].sum() / num_vectors  # Using the highest VETH value
print(f"Effectiveness of the dynamic threshold: {effectiveness}")

# c. Identify discrepancies and explain potential causes
discrepancies = np.abs(errors)
mean_discrepancy = np.mean(discrepancies)
max_discrepancy = np.max(discrepancies)
print(f"Mean Discrepancy: {mean_discrepancy}")
print(f"Maximum Discrepancy: {max_discrepancy}")

# d. Assess the accuracy and efficiency of this example detection method
accuracy = effectiveness
efficiency = mean_discrepancy
print(f"Accuracy: {accuracy}")
print(f"Efficiency (mean discrepancy): {efficiency}")

