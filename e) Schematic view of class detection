import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# Define the class detection circuit model
def class_detection_circuit(x, xi_classes, G_u, V_u, R_f):
    V_outs = []
    D_squared_list = []
    
    for xi in xi_classes:
        # Calculate the squared Euclidean distance
        D_squared = np.sum((x - xi) ** 2)
        D_squared_list.append(D_squared)
        # Output voltage
        V_out = R_f * V_u * G_u * D_squared
        V_outs.append(V_out)
        
    return V_outs, D_squared_list

# Comparator output function
def comparator_output(V_out, V_CTH):
    return V_out > V_CTH

# Define parameters
G_u = 1e-6 # S (1 μS)
V_u = 1 # V
R_f = 1e4 # Ω (10 kΩ)
V_CTH_range = np.linspace(0.01, 0.1, 10) # Class threshold range

# Input vector and stored vectors for each class
x = np.array([1, 2, 3])
xi_classes = [np.array([2, 3, 4]), np.array([1, 1, 1]), np.array([3, 3, 3])]

# Calculate the expected distances and output voltages
V_outs, D_squared_list = class_detection_circuit(x, xi_classes, G_u, V_u, R_f)
D_list = np.sqrt(D_squared_list)

# Comparator outputs for different V_CTH values
comp_outputs = np.array([[comparator_output(V_out, V_CTH) for V_CTH in V_CTH_range] for V_out in V_outs])

# Print results
print(f"Expected Euclidean distances: {D_list}")
print(f"Output voltages of the operational amplifiers: {V_outs}")
print("Comparator outputs for different V_CTH values:")
for i, outputs in enumerate(comp_outputs):
    print(f"Class {i+1} comparator outputs: {outputs}")

# Plot results
plt.figure(figsize=(15, 5))

# Plot 1: Operational amplifier output vs. input current
plt.subplot(1, 3, 1)
plt.plot(D_list, V_outs, 'ro')
plt.xlabel('Euclidean Distance')
plt.ylabel('Operational Amplifier Output (V)')
plt.title('Op-Amp Output vs. Distance')
plt.grid(True)

# Plot 2: Comparator output vs. V_CTH
plt.subplot(1, 3, 2)
for i, outputs in enumerate(comp_outputs):
    plt.plot(V_CTH_range, outputs, label=f'Class {i+1}')
plt.xlabel('Class Threshold Voltage (V_CTH)')
plt.ylabel('Comparator Output')
plt.title('Comparator Output vs. V_CTH')
plt.legend()
plt.grid(True)

# Plot 3: Classification decision vs. V_CTH
plt.subplot(1, 3, 3)
decisions = np.argmax(comp_outputs, axis=0)
plt.plot(V_CTH_range, decisions, 'b-o')
plt.xlabel('Class Threshold Voltage (V_CTH)')
plt.ylabel('Classification Decision (Class Index)')
plt.title('Classification Decision vs. V_CTH')
plt.grid(True)

plt.tight_layout()
plt.show()

# Simulate multiple input vectors
np.random.seed(42)  # For reproducibility
num_samples = 50
x_samples = np.random.randint(0, 5, (num_samples, len(x)))

# Calculate Euclidean distances and classify each sample
true_classes = np.zeros(num_samples, dtype=int)
predicted_classes = np.zeros(num_samples, dtype=int)

for i, x_sample in enumerate(x_samples):
    _, D_squared_sample = class_detection_circuit(x_sample, xi_classes, G_u, V_u, R_f)
    D_sample = np.sqrt(D_squared_sample)
    true_classes[i] = np.argmin(D_sample)
    V_outs_sample, _ = class_detection_circuit(x_sample, xi_classes, G_u, V_u, R_f)
    decisions_sample = np.argmax(np.array([[comparator_output(V_out, V_CTH) for V_CTH in V_CTH_range] for V_out in V_outs_sample]), axis=0)
    predicted_classes[i] = decisions_sample[-1]

# Error analysis
accuracy = np.sum(true_classes == predicted_classes) / num_samples
print(f"Classification Accuracy: {accuracy * 100:.2f}%")
